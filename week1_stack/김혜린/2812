## Code explanation
## 1. 우선 받기전 그냥 수를 받을 리스트, 그리고 mod개 (0~mod-1)까지 수가 나왔는지, 언제 나와서 몇번째 인덱스에 존재하는지 확인하는 이중리스트 를 생성한다
## 2. 1 num 이 나올 경우 mod로 나눠 나머지를 저장하고, 이 나머지의 리스트 (예를 들어 나머지가 3이면 3의 리스트)에 지금 몇번째 나온 수인지 인덱스를 저장한다.
## 3. 2는 그냥 pop 하면서 저장한거 빼고, 인덱스 저장한거 뺀다.
## 4-1. 3의 경우가 중요한데, 뒤에서부터 순서대로 다나왔는지 확인하니까 최악의 경우는 리스트 전체를 다봐야 하는 경우라 min_count = len(arr)로 설정한다.
## 4-2. 그리고 우선 나머지가 한번씩은 나와야 되니까 이중 리스트 돌면서 리스트가 빈경우가 있다면 -1하고 끝낸다.
## 4-3. 만약 모두 있다면, 어디까지가 최소로 나와야 성립하는지 알아야 하니까, 각 나머지 리스트마다 최대 인덱스 (여기서는 따라서 그 나머지 리스트의 -1번째 (마지막) 인덱스)를 뽑고, 이것과 현재 min_count 중 더 작은걸 저장한다. (최소로 나와야 하는 거니까 더 작은걸 골라야함)
## 4-4. 모든 나머지 리스트를 돌고, 최소 여기 인덱스까지 나와야한다 = min_count를 뽑으면 이걸 전체 길이에서 빼서 갯수를 찾는다.

## import lib
import sys

## main
num, delete_num = map(int, sys.stdin.readline().split())
input_num = sys.stdin.readline().split()[0]
number_stack = []

# 나중에 delete_num이 다 안빠질 수도 있어서 체크용
left = len(input_num) -1
for i in range(len(input_num)):
    if delete_num == 0:
    	# 다 빠졌다면 끝내고 남은 숫자 수 left에 저장
        left = i
        break
    # delete_num > 0 이라면 앞에 수가 나보다 클때까지, 계속 제거할 수 있음
    while(len(number_stack)):
        if delete_num == 0:
            break
        if number_stack[-1] < int(input_num[i]):
            number_stack.pop()
            delete_num -= 1
        else:
            break
    number_stack.append(int(input_num[i]))

# 만약 delete_num이 남아있다면 스택에서 초과한만큼 제거,,
if left >= len(input_num)-1:
    if delete_num > 0:
        while (delete_num):
            number_stack.pop()
            delete_num -= 1
    total = 0
    i = 1
else:
    total = int(input_num[left:])
    i = 10**(len(input_num[left:]))

# 10단위로 늘려가면서 pop 하면서 더하기~
while(len(number_stack) != 0):
    total += i * (number_stack.pop())
    i *= 10
print(total)
